了解事件机制，是前端开发中的一个重中之重。如果使用原生js来进行事件绑定，往往我们都要写很多的代码，来进行兼容性的判断。    
下面是一个简单事件绑定函数：

	function addEvent(ele,type,listener){
		var node = document.getElementById('ele');
		if(node.addEventListener){//ff浏览器
			node.addEventListener(type,func,false);
			return true;
		}else if(node.attachEvent){//兼容低版本ie浏览器
			node['e'+type+listener]=listener;
			node[type+listener]=function(){
				node['e'+type+listener](window.event);
			};
			node.attachEvent('on'+type,node[type+listener]);
			return true;
		}
		return false;
	}

对事件的操作除了事件绑定，还有很多其他操作，比如事件移除，event对象的封装，事件名的兼容等等，如果都要自己来实现确实得费一番功夫。软件工程中有一句话，“我们不用制造重复的轮子”，所以，现在都在使用jQuery来做事件的处理。闲话不多说，先来看看jQuery中事件绑定与解绑的一些处理。

首先，需要明确的知道，事件函数都是绑定在DOM节点上的。所以，jQuery将事件处理函数扩展到了实例方法上。

	jQuery.fn.extend({
		on:function(types, selector, data, fn, /*INTERNAL*/ one) {...},
		one: function(types, selector, data, fn) {...},
		off: function(types, selector, fn) {...},
		trigger: function(type, data) {...},
		triggerHandler: function(type, data) {...}
	});



上面的这些方法都是事件处理函数中比较核心的一些方法，其他很多方法都是通过调用这些方法来实现的，但是他们本身并不是真正的事件处理函数，真正的事件处理函数都方法了jQuery.event对象上。所以说这几个方法就相当于是一个中间层，往上被一些方法别名调用，往下调用的是jQuery.event对象上的方法。

![jQuery事件处理结构](http://i.imgur.com/n8yZGON.png)    




可以看出来on方法，在这其中起了至关重要的作用。下面来解读on方法各个参数的含义：

	on:function(types, selector, data, fn, /*INTERNAL*/ one) {...}


> 1. types： 表示事件绑定的类型
> 2. selector： 进行事件委托的选择器
> 3. data： 触发事件函数时，可以通过data进行参数的传递，使用event.data获取
> 4. fn： 事件函数
> 5. one： 如果为true，就表示该事件只会触发一次


在第6720行可以看到，这些方法其实都是调用的on方法，他们都是on方法的别名

	jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
	
		// Handle event binding    通过事件名的方式绑定事件
		jQuery.fn[ name ] = function( data, fn ) {   //调用该方法时，如果没有传入要事件函数，则激活该事件，调用trigger方法
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	});
	
	jQuery.fn.extend({
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		},
	
		bind: function( types, data, fn ) {  //on方法的别名
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {   //这里也是on方法的别名
			return this.on( types, selector, data, fn );  //进行事件委托，本质还是调用on方法，只是把参数的顺序进行了调整
		},
		undelegate: function( selector, types, fn ) {
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
		}
	});