之前已经分析过了，在用通过on方法绑定的事件和通过off方法移除的事件，最后都会交由jQuery.event对象下的方法来处理。那么jQuery.event到底具有哪些方法呢？

	jQuery.event = {
		global     事件的全局属性，但是该版本并没有用到
		add        添加事件
		remove     移除事件
		trigger    激活事件
		dispatch   派发事件的具体操作
		handlers   事件函数的执行顺序
		
		special    特殊事件的处理
		simulate   特殊事件的模拟操作

		//下面的几个方法都是对event对象封装的一些操作
		props      event的一些属性
		fixHooks   event兼容处理的集合
		keyHooks   对键盘事件event对象的兼容处理
		mouseHooks 对鼠标事件event对象的兼容处理
		fix        event对象的封装处理
	}


暂且只看绑定事件对事件函数做了哪些处理，如果理解了事件绑定的一些处理，那么后面的移除事件和事件激活也就很好理解了。

jQuery在绑定事件时，一共做了如下操作：

1. 通过data缓存机制，将事件函数进行缓存；
2. 通过dispatch重新封装事件函数；
3. 通过fix来修正event对象在各个浏览器下的不同表现；
4. 通过handlers修正事件触发的顺序


> 在add方法一开始就可以看到如下代码：

	elemData = data_priv.get( elem );

通过缓存机制，把事件函数进行存储，那么存储过后的事件对象到底是什么样子呢？

这里可以使用console.log()将缓存的事件对象进行打印：

	elemData = {//该对象是缓存在DOM节点下
		events:{  //不同的事件类型以数组的方式进行缓存
			'click': [//length: 3 , delegateCount:1 有事件代理的个数
				{
					data:"111",
					guid:3,
					handler:function(){},
					namespace:"",
					needsContext:false,
					origType:"click",
					selector:"#second",
					type:"click",
				},
				{},
				{}
			],
			'mouseover': [
				{
					data:undefined,
					guid:4,
					handler:function(){},
					namespace:"",
					needsContext:undefined,
					origType:"mouseenter",
					selector:undefined,
					type:"mouseover",
				}
			]
		},
		handle:function (e) {}
	}


下面看看这个对象缓存的属性具体代表什么含义：
	
	events: {  //存储着各个类型事件函数的数组
		'click':[  //数组中以对象的形式存储着每个事件函数的具体信息
			{
				data: //传递到事件函数的数据
				guid: //每个事件函数的唯一标识
				handler: //存储着事件函数
				namespace: //命名空间
				needsContext: //表示是否进行委托，有委托为false，没有委托为undefined
				selector: //要进行事件代理的选择器
				origType: //初始的事件类型
				type: //使用兼容处理后的事件类型
			}
		]
		//每个数组下还有一个属性-》delegateCount:1 表示是事件代理函数的个数
		//且数组前面为进行事件委托的事件函数，后面的是没有事件委托的事件函数
	},
	handle: function(e) {}  //真正绑定到节点的事件函数
	//handle.elem: 缓存了当前节点的引用