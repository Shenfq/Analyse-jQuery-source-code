之前已经分析过了，在用通过on方法绑定的事件和通过off方法移除的事件，最后都会交由jQuery.event对象下的方法来处理。那么jQuery.event到底具有哪些方法呢？

	jQuery.event = {
		global     事件的全局属性，但是该版本并没有用到
		add        添加事件
		remove     移除事件
		trigger    激活事件
		dispatch   派发事件的具体操作
		handlers   事件函数的执行顺序
		
		special    特殊事件的处理
		simulate

		//下面的几个方法都是对event对象封装的一些操作
		props      event的一些属性
		fixHooks   event兼容处理的集合
		keyHooks   对键盘事件event对象的兼容处理
		mouseHooks 对鼠标事件event对象的兼容处理
		fix        event对象的封装处理
	}


今天我们只看绑定事件对事件函数做了哪些处理，如果理解了事件绑定的一些处理，那么后面的移除事件和事件激活也就很好理解了。

jQuery在绑定事件时，一共做了如下操作：

1. 通过data缓存机制，将事件函数进行缓存；
2. 通过dispatch重新封装事件函数；
3. 通过fix来修正event对象在各个浏览器下的不同表现。


> 在add方法一开始就可以看到如下代码：

	elemData = data_priv.get( elem );

通过缓存机制，把事件函数进行存储，那么存储过后的事件对象到底是什么样子呢？

这是我们可以使用console.log()将缓存的事件对象进行打印：

	elemData = {//该对象是缓存在DOM节点下
		events:{  //不同的事件类型已数组的方式进行缓存
			'click': [  //每个事件类型属性下都是一个数组，事件委托从队列头部推入，而普通事件绑定从尾部推入，通过记录delegateCount来划分，委托(delegate)绑定和普通绑定。
				//length: 3 , delegateCount:1 有事件代理的个数
				{
					data:"111",
					guid:3,
					handler:function(){},
					namespace:"",
					needsContext:false,
					origType:"click",
					selector:"#second",
					type:"click",
				},
				{},
				{}
			],
			'mouseover': [
				{
					data:undefined,
					guid:4,
					handler:function(){},
					namespace:"",
					needsContext:undefined,
					origType:"mouseenter",
					selector:undefined,
					type:"mouseover",
				}
			]
		},
		handle:function (e) {  //elem:div#box2
			
		}
	}